\chapter{Analiza wyników badań}\label{Chapter_AnalizaRezultatow}

  \section{Opis wygenerowanych zbiorów i~rezultatów}\label{Section_Results}
    Zanim zostaną dokładnie omówione i~przeanalizowane wyniki przeprowadzonych badań, warto przybliżyć kilka szczegółów dotyczących zebranych rezultatów.

    Wszystkie wyniki zostały zebrane z~plikach z~rozszerzeniem JSON (są to samoopisujace się pliki tekstowe ogólnego przeznaczenia, oparte na strukturze słownika typu \textit{klucz} - \textit{wartość}). Rozmiar wygenerowanych danych wynosi $4,1$ MB, co jak na dane czysto tekstowe jest dość dużą liczbą (ponad 4 miliony znaków).

    Czas trwania podstawowych testów (analiza wszystkich zebranych próbek - 3 różne algorytmy o~domyślnych parametrach, 10 osób po 6 gestów) to ponad dwie i~pół godziny. Dla wyspecjalizowanych przypadków czas przetwarzania wyniósł trzy i~pół godziny (wybrane parametry dla 3 algorytmów na 2 najlepszych jakościowo próbkach 2 gestów). Przypadki dodatkowe zostały zebrane w~pliku \textit{parametrized.json} umieszczonym w~katalogu głównym kodu źródłowego.

    W~przypadku algorytmu opartego na uczeniu maszynowym, rozmiar wygenerowanych zbiorów treningowych dla domyślnych parametrów (las złożony z~5~drzew losowych, 200 punktów charakterystycznych, wymiar boku kwadratowej łaty - 20 pikseli) wyniósł dokładnie $43$ GB. Czas generacji został uwzględniony w~powyższym akapicie.

    Rezultaty zostały zebrane za pomocą 64 wykresów, analizujących cztery różne obszary porównawcze, tj.:
    \begin{itemize}
      \item Zużycie pamięci wirtualnej i~fizycznej.
      \item Wydajność (czas przetwarzania klatki animacji oraz czas dodatkowych operacji niezbędnych do obliczeń).
      \item Narzut czasowy obliczeń, wprowadzony do nominalnego czasu trwania sekwencji wideo.
      \item Jakość wygenerowanej ścieżki w~stosunku do wyznaczonych manualnie punktów i~ścieżek kluczowych.
    \end{itemize}

    W~kolejnych sekcjach zostały szczegółowo omówione wyniki oraz przedstawione wnioski dla każdego z~analizowanych obszarów.

  \section{Wnioski i~wyniki związane z~zużyciem pamięci badanych algorytmów}\label{Section_Memory}

    Zaimplementowane algorytmy posiadają zupełnie trzy odrębne profile pamięciowe co zamieszczone zostało na wykresach \ref{fig:MemoryUsagePersonAC} oraz \ref{fig:MemoryUsagePersonGC}, reprezentujących dwie odrębne próbki. W~przypadku metod opartych o~rodzinę algorytmów przepływu optycznego wartość zużywanej pamięci nie różni się pomiędzy poszczególnymi próbkami. Dla trzeciego algorytmu zużycie waha się w~przedziale od $350$ do $800$ MB dla pamięci wirtualnej i~dla pamięci fizycznej w~przedziale od $150$ do $600$ MB. Widać wyraźnie, że najwięcej pamięci pochłania implementacja opierająca się algorytmie wykorzystującym las drzew losowych i~ilość zaalokowanej pamięci zależy ściśle od przygotowanej bazy treningowej oraz parametrów próbki wideo.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/memory/PersonAC}
      \caption[Wykres zużycia pamięci dla próbki o nazwie Person\_A\_C]
              {Wykres zużycia pamięci dla próbki o nazwie \textit{Person\_A\_C}}
      \label{fig:MemoryUsagePersonAC}
    \end{figure}

    W~przypadku gęstego przepływu optycznego zużycie pamięci fizycznej nie przekracza $80$ MB, dla implementacji algorytmu opartego o~metodę \textit{LK} osiąga wartość co najwyżej $50$ MB. Oba algorytmy są zdecydowanie oszczędniejsze od trzeciej zaproponowanej implementacji.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/memory/PersonGC}
      \caption[Wykres zużycia pamięci dla próbki o nazwie Person\_G\_C]
              {Wykres zużycia pamięci dla próbki o nazwie \textit{Person\_G\_C}}
      \label{fig:MemoryUsagePersonGC}
    \end{figure}

    Algorytm gęstego przepływu optycznego posiada jedną wadę - mimo stosunkowo niewielkiego zużycia pamięci, na wykresie \ref{fig:OpticalFlowsMemoryUsage} został zaprezentowany piłokształtny przebieg, ciągłej alokacji i~zwalniania od 2 do 4 MB bufora pamięci pomiędzy poszczególnymi klatkami sekwencji wideo. Nie jest to korzystne zjawisko i~jego eliminacja na pewno wpłynie pozytywnie na całkowitą wydajność.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/memory/OpticalFlows}
      \caption[Wykres zużycia pamięci dla algorytmów przepływu optycznego]
              {Wykres zużycia pamięci dla algorytmów przepływu optycznego}
      \label{fig:OpticalFlowsMemoryUsage}
    \end{figure}

    W~przypadku algorytmu opartego o~las drzew losowych zużycie pamięci liniowo zależy od ilości wytrenowanych drzew wykorzystanych do budowy klasyfikatora. Zależność została zaprezentowana na rysunku \ref{fig:RandomForestTrackerPerTrainedTreesAmount}. Jednocześnie można zauważyć, że różnica pomiędzy minimalnym i~maksymalnym zużyciem pamięci jest niewielka co oznacza, że proces potrzebuje dużej ilości pamięci, ale nie jest algorytmem intensywnym w~operacje przydzielania i~zwalniania zasobów.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/memory/RandomPerTrainedTree}
      \caption[Wykres zużycia pamięci dla algorytmu lasu drzew losowych w~zależności od liczby wytrenowanych drzew]
              {Wykres zużycia pamięci dla algorytmu lasu drzew losowych w~zależności od liczby wytrenowanych drzew}
      \label{fig:RandomForestTrackerPerTrainedTreesAmount}
    \end{figure}

    Rzadki przepływ optyczny charakteryzuje się niewielkimi wahaniami zużycia pamięci w~zależności od minimalnej odległości pomiędzy śledzonymi punktami charakterystycznymi (jak można było przypuszczać, im większa odległość tym mniejsze zużycie pamięci). Na wykresie \ref{fig:SparseOpticalFlowPerMinimalDistanceBetweenPoints} widać, że fluktuacje mieszczą się w~przedziale o~szerokości około $30$ MB i~nie przekraczają wartości $63$ MB, co nie jest bez znaczenia w~środowisku z~ograniczonymi zasobami pamięciowymi (np. systemy wbudowane lub urządzenia mobilne). Z trzech porównywanych implementacji, metoda oparta o~algorytm \textit{LK} w~wariancie piramidalnym jest najbardziej optymalna pod względem zużycia pamięci.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/memory/SparsePerMinimalDistance}
      \caption[Wykres zużycia pamięci dla rzadkiego przepływu optycznego w~zależności przyjętej minimalnej odległości pomiędzy punktami charakterystycznymi]
              {Wykres zużycia pamięci dla rzadkiego przepływu optycznego w~zależności przyjętej minimalnej odległości pomiędzy punktami charakterystycznymi}
      \label{fig:SparseOpticalFlowPerMinimalDistanceBetweenPoints}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/memory/DensePerMapOverlaySize}
      \caption[Wykres zużycia pamięci dla gęstego przepływu optycznego w~zależności od gęstości siatki]
              {Wykres zużycia pamięci dla gęstego przepływu optycznego w~zależności od gęstości siatki}
      \label{fig:DenseOpticalFlowPerMapSize}
    \end{figure}

    \newpage

    W~wariancie gęstym zależnym od rozmiaru przyjętej siatki, przepływ optyczny charakteryzuje się wyższym zużyciem pamięci (maksymalnie około $72$ MB), jednak same wahania są stabilniejsze, mieszczą się w~przedziale o~szerokości około $5$ MB. Widać, że zwiększenie wymiarów siatki (intuicyjnie, rozrzedzenie jej) nie zawsze idzie w~parze z~malejącym zużyciem pamięci. Warto jednak zauważyć, że wahania odbywają się w~bardzo niewielkim zakresie.

    Mimo wyższego zużycia całościowego, jego wartość nadal nie jest zbyt wysoka i~algorytm gęstego przepływu optycznego sprawdzi się w~środowisku z~ograniczonymi zasobami pamięciowymi.

  \section{Wnioski i~wyniki badania wydajności zaimplementowanych algorytmów}\label{Section_Timing}

    Pod pojęciem badań wydajności zostały zebrane wszystkie testy oraz wykresy prezentujące czas przetwarzania pojedynczej klatki algorytmu. Wszystkie implementacje zostały szczegółowo zbadane pod tym kątem, aby wybrać algorytm najefektywniejszy i~dokładający najmniejszy narzut w~każdej kolejnej klatce sekwencji wideo.

    Na wykresach \ref{fig:DenseTimingPersonAC}, \ref{fig:RandomTimingPersonAC} oraz \ref{fig:SparseTimingPersonAC} widać wartości czasu przetwarzania klatki, wraz z~naniesioną wartością średnią dla zaimplementowanych algorytmów kolejno przepływu w~wariancie gęstym, wykorzystującym lasy drzew losowych oraz rzadkiego przepływu optycznego.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/timing/DenseTimingPersonAC}
      \caption[Wykres czasu przetwarzania klatki dla algorytmu gęstego przepływu optycznego]
              {Wykres czasu przetwarzania klatki dla algorytmu gęstego przepływu optycznego}
      \label{fig:DenseTimingPersonAC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12cm]{charts/timing/RandomTimingPersonAC}
      \caption[Wykres czasu przetwarzania klatki dla algorytmu lasu drzew losowych]
              {Wykres czasu przetwarzania klatki dla algorytmu lasu drzew losowych}
      \label{fig:RandomTimingPersonAC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12cm]{charts/timing/SparseTimingPersonAC}
      \caption[Wykres czasu przetwarzania klatki dla algorytmu rzadkiego przepływu optycznego]
              {Wykres czasu przetwarzania klatki dla algorytmu rzadkiego przepływu optycznego}
      \label{fig:SparseTimingPersonAC}
    \end{figure}

    Widać, że najmniejszym średnim czasem przetwarzania charakteryzują się dwa ostatnie algorytmu. Gęsty przepływ optyczny jest algorytmem o~bardzo dużym koszcie obliczeniowym, co objawia się bardzo wysokimi wartościami czasu przetwarzania klatki (oraz w~konsekwencji dużo wyższą wartością średnią). Zależność tą najlepiej widać na wykresach \ref{fig:PersonBO} oraz \ref{fig:PersonGO}.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/timing/PersonBO}
      \caption[Porównanie czasu przetwarzania klatki dla próbki Person\_B\_O]
              {Porównanie czasu przetwarzania klatki dla próbki \textit{Person\_B\_O}}
      \label{fig:PersonBO}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/timing/PersonGO}
      \caption[Porównanie czasu przetwarzania klatki dla próbki Person\_G\_O]
              {Porównanie czasu przetwarzania klatki dla próbki \textit{Person\_G\_O}}
      \label{fig:PersonGO}
    \end{figure}

    Warto zauważyć, że praktycznie każdy z~algorytmów charakteryzuje się niewielkimi wahaniami w~zakresie czasu przetwarzania (wyjątkiem jest początkowa faza działania algorytmu gęstego przepływu optycznego, gdzie następuje inicjalizacja macierzy przepływu, w~kolejnym etapie czas przetwarzania stabilizuje się).

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=10cm]{charts/timing/StackedDensePersonEGestureCrush}
      \caption[Narzut czasowy dodatkowych etapów przetwarzania dla każdej klatki\\(gęsty przepływ optyczny)]
              {Narzut czasowy dodatkowych etapów przetwarzania dla każdej klatki\\(gęsty przepływ optyczny)}
      \label{fig:StackedDense}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=10cm]{charts/timing/StackedSparsePersonEGestureCrush}
      \caption[Narzut czasowy dodatkowych etapów przetwarzania dla każdej klatki\\(rzadki przepływ optyczny)]
              {Narzut czasowy dodatkowych etapów przetwarzania dla każdej klatki\\(rzadki przepływ optyczny)}
      \label{fig:StackedSparse}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12cm]{charts/timing/StackedRandomPersonEGestureCrush}
      \caption[Narzut czasowy dodatkowych etapów przetwarzania dla każdej klatki\\(las drzew losowych)]
              {Narzut czasowy dodatkowych etapów przetwarzania dla każdej klatki\\(las drzew losowych)}
      \label{fig:StackedRandom}
    \end{figure}

    Reprezentacja graficzna narzutu dodatkowych etapów przetwarzania została zamieszczona na wykresach \ref{fig:StackedDense}, \ref{fig:StackedSparse} oraz \ref{fig:StackedRandom}. Widać wyraźnie, że w~przypadku algorytmów z~rodziny przepływu optycznego dodatkowy narzut mieści się w~granicy błędu statystycznego (maksymalne wartości odpowiednio $0.6$ oraz $0.33$ milisekundy).

    W~przypadku algorytmu opartego o~uczenie maszynowe, odzyskanie reprezentacji śledzonych punktów wiąże się z~niewielkim narzutem czasowym, odzwierciedlonym na przebiegu \ref{fig:StackedRandom} (maksymalnie ok. $50$ milisekund).

    Dla algorytmu gęstego przepływu optycznego najcięższą przeprawą jeśli chodzi o~przetwarzanie okazał się zestaw próbek \textit{G}, choć tak naprawdę czasy przetwarzania wszystkich zbiorów mieszczą się w~przedziale o~dość niewielkiej szerokości (jeśli chodzi o~średnie czas przetwarzania, przedział ma szerokość około $20$ milisekund). Omawiana implementacja charakteryzuje się bardzo stabilnym czasem przetwarzania pojedynczej klatki. Niemniej, jest to zbyt duża wartość, aby można było mówić o~zastosowaniu tej metody w~przypadku ścisłych wymagań czasowych.

    Tak jak w~przypadku zbiorów, również podział ze względu na gesty dla wybranej próbki charakteryzuje się stabilnym czasem przetwarzania. Różnice pomiędzy średnimi wartościami są niewielkie (szerokość przedziału to około 25 milisekund).

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12cm]{charts/timing/DenseForGestureC}
      \caption[Czas przetwarzania klatki poszczególnych osób dla gestu C]
              {Czas przetwarzania klatki poszczególnych osób dla gestu \\\textit{Wielka Litera C} (gęsty przepływ optyczny)}
      \label{fig:DenseForGestureC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=13cm]{charts/timing/DenseTimingForPersonE}
      \caption[Czas przetwarzania klatki poszczególnych gestów dla osoby E]
              {Czas przetwarzania klatki poszczególnych gestów dla osoby \textit{E}\\(gęsty przepływ optyczny)}
      \label{fig:DenseTimingForPersonE}
    \end{figure}

    \newpage
    Na wykresie \ref{fig:DenseTimingPerMapSize} została przedstawiona zależność czasu przetwarzania od rozmiaru siatki. Intuicyjnie dla małych wartości wraz z~rozrzedzaniem gęstości siatki maleje czas przetwarzania. Po osiągnięciu pewnego pułapu (w~okolicach 10 pikseli) czas przetwarzania stabilizuje się na wcześniej obserwowanej wartości.

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/timing/DenseTimingPersonG_OC_perMapSize}
      \caption[Czas przetwarzania klatki w~zależności od rozmiaru siatki]
              {Czas przetwarzania klatki w~zależności od rozmiaru siatki\\(próbki \textit{Person\_G\_O} oraz \textit{Person\_G\_C})}
      \label{fig:DenseTimingPerMapSize}
    \end{figure}

    Analogiczny zestaw testów został przeprowadzony na algorytmie wykorzystującym las drzew losowych.

    W~jego przypadku największym wyzwaniem okazał się zbiór \textit{B} (rysunek \ref{fig:RandomForGestureC}). Warto zwrócić na stosunkowo niski średni czas przetwarzania w~porównaniu do uprzednio omawianego algorytmu. W~przypadku podziału na gesty, wartości minimalne, maksymalne oraz średnie są zbliżone do poprzedniej reprezentacji (wykres \ref{fig:RandomTimingForPersonE}). Algorytm charakteryzuje się niskim i~dość stabilnym średnim czasem przetwarzania klatki sekwencji wideo.

    W~przypadku tej konkretnej implementacji bardzo ważnym parametrem jest czas uczenia klasyfikatora przedstawiony w~zależności od liczby wykorzystanych drzew losowych. Omawiana reprezentacja zostały przedstawione na wykresie \ref{fig:LearningTime}.

    Równie ważnym parametrem jest wartość czasu przetwarzania klatki w~zależności od liczby wytrenowanych drzew. Zależność została przedstawiona na rysunku \ref{fig:TimingPerTrainedTreesAmount}.

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12cm]{charts/timing/RandomForGestureC}
      \caption[Czas przetwarzania klatki poszczególnych osób dla gestu C]
              {Czas przetwarzania klatki poszczególnych osób dla gestu\\\textit{Wielka Litera C} (las drzew losowych)}
      \label{fig:RandomForGestureC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12cm]{charts/timing/RandomTimingForPersonE}
      \caption[Czas przetwarzania klatki poszczególnych gestów dla osoby E]
              {Czas przetwarzania klatki poszczególnych gestów dla osoby \textit{E}\\(las drzew losowych)}
      \label{fig:RandomTimingForPersonE}
    \end{figure}

    \newpage
    Jak widać na wykresie \ref{fig:LearningTime} wprowadzony przez ten konkretny algorytm narzut czasowy jest znaczny oraz jest wprost proporcjonalny do liczby wytrenowanych drzew. Jest to największa wada algorytmu jeśli chodzi o~wydajność. Każda metoda wykorzystująca uczenie maszynowe, wprowadza spory narzut przeznaczony na przygotowanie klasyfikatora. Nie jest to jednak argument dyskryminujący, ponieważ przygotowana implementacja pozwala na dalsze optymalizacje i~zminimalizowanie czasu uczenia (usprawnienia zostały zebrane w~rozdziale \ref{Section_Usprawnienia}).

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=13cm]{charts/timing/LearningTimePerTrainedTreesAmount}
      \caption[Czas nauki klasyfikatora w~zależności od liczby drzew losowych]
              {Czas nauki klasyfikatora w~zależności od liczby drzew losowych}
      \label{fig:LearningTime}
    \end{figure}

    Dla czasu przetwarzania klatki liczba drzew losowych ma niewielkie znaczenie. Wahania średniego czasu przetwarzania zaprezentowane na wykresie \ref{fig:TimingPerTrainedTreesAmount} mieszczą się w~przedziale o~szerokości około 20 milisekund. Dodatkowo widać, że im większa wytrenowanych drzew losowych tym stabilniejsza średnia wartość, jednocześnie nieznacznie zwiększa się minimalna wartość (wartości maksymalne czasu przetwarzania silnie zależą od określonej próbki).

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=13cm]{charts/timing/RandomTimingPersonG_OC_perTrainedTrees}
      \caption[Czas przetwarzania klatki w~zależności od liczby wytrenowanych drzew losowych]
              {Czas przetwarzania klatki w~zależności od liczby wytrenowanych drzew losowych (próbki \textit{Person\_G\_O} oraz \textit{Person\_G\_C})}
      \label{fig:TimingPerTrainedTreesAmount}
    \end{figure}

    \newpage
    Rzadki przepływ optyczny jest algorytmem o~najniższym średnim czasie przetwarzania klatki. Widać to na wykresach \ref{fig:SparseForGestureC} oraz \ref{fig:SparseTimingForPersonE}. Algorytm najlepiej poradził sobie praktycznie z~każdym zbiorem (wyjątkiem jest zbiór \textit{A}, jednak średnia wartość jest i~tak najniższa spośród trzech implementacji).

    Również, jeśli chodzi o~podział ze względu na gesty omawiana implementacja jest najwydajniejsza. W~obu przypadkach wartości średnie przetwarzania klatki animacji nie przekraczają 40 milisekund, maksymalne - tylko w~jednym przypadku przekraczają 50 milisekund. Implementacja może zostać wykorzystana w~warunkach o~dużych wymaganiach jeśli chodzi o~narzut przetwarzania pojedynczej ramki sekwencji wideo.

    Omawiana metoda charakteryzuje się liniową zależnością czasu obliczeń na pojedynczej klatce w~zależności od maksymalnej liczby punktów charakterystycznych (wykres \ref{fig:TimingPerFeaturesAmount}) oraz zależnością zbliżoną do logarytmicznej jeśli chodzi o~minimalną odległość pomiędzy punktami wyznaczonymi przez algorytm (wykres \ref{fig:TimingPerMinimalDistance}).

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12.5cm]{charts/timing/SparseForGestureC}
      \caption[Czas przetwarzania klatki poszczególnych osób dla gestu C]
              {Czas przetwarzania klatki poszczególnych osób dla gestu\\\textit{Wielka Litera C} (rzadki przepływ optyczny)}
      \label{fig:SparseForGestureC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12.5cm]{charts/timing/SparseTimingForPersonE}
      \caption[Czas przetwarzania klatki poszczególnych gestów dla osoby E]
              {Czas przetwarzania klatki poszczególnych gestów dla osoby \textit{E}\\(rzadki przepływ optyczny)}
      \label{fig:SparseTimingForPersonE}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12.5cm]{charts/timing/SparseTimingPersonG_OC_perFeaturesAmount}
      \caption[Czas przetwarzania klatki w~zależności od maksymalnej ilości punktów charakterystycznych]
              {Czas przetwarzania klatki w~zależności od maksymalnej ilości punktów charakterystycznych (próbki \textit{Person\_G\_O} oraz \textit{Person\_G\_C})}
      \label{fig:TimingPerFeaturesAmount}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=12.5cm]{charts/timing/SparseTimingPersonG_OC_perMinimalDistance}
      \caption[Czas przetwarzania klatki w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi]
              {Czas przetwarzania klatki w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi (próbki \textit{Person\_G\_O} oraz \textit{Person\_G\_C})}
      \label{fig:TimingPerMinimalDistance}
    \end{figure}

  \section{Wnioski i~wyniki związane z~wprowadzonym narzutem czasowym}\label{Section_Overhead}
    Na podstawie wyników zaprezentowanych w~poprzedniej sekcji można skutecznie określić, który algorytm wprowadza najmniejszy całkowity narzut czasowy przetwarzania sekwencji wideo. Na wykresie \ref{fig:OverheadGL} zostały zestawione wartości dla każdego z~algorytmów. Najbardziej optymalnym algorytmem jest algorytm przepływu optycznego w~wariancie rzadkim.

    Porównanie zawarte na wykresie omówionym powyżej, nie zawiera pełnego narzutu dla metody opartej o~uczenie maszynowe. Całkowite podsumowanie zostało umieszczone na rysunku \ref{fig:RandomForestTrackerOverhead}. Widać wyraźnie, że w~przypadku pełnej generacji (zapisu, odczytu i~budowania bazy treningowej) dla jednego drzewa narzut jest ogromny (około 1 minuty). Mimo, iż narzut czasowy wprowadzony tylko poprzez klasyfikacji w~oparciu o~wytrenowany zbiór jest niski, to metoda jest bardzo kosztowna. W~sekcji \ref{Section_Usprawnienia} zwrócono uwagę na analizowany problem i~zaproponowano potencjalne rozwiązanie.

    Na wykresach \ref{fig:SpecialisedDenseOverhead}, \ref{fig:SpecialisedRandomOverhead} oraz \ref{fig:SpecialisedSparseOverhead} zaprezentowane zostały zależności całkowitego narzutu czasowego w~odniesieniu do podstawowych parametrów zaimplementowanych metod.

    W~przypadku algorytmu gęstego przepływu optycznego, narzut zmniejsza się wraz z~rozrzedzeniem siatki (zwiększeniem rozmiaru jej oczka) i~stabilizuje się w~okolicy rozmiaru równego 10 pikseli. Jak zostanie przedstawione w~następnym rozdziale wspomniana wartość może zostać przyjęta jako rozsądny kompromis pomiędzy jakością jak i~czasem działania algorytmu.

    Dla algorytmu wykorzystującego las drzew losowych całkowity narzut stabilizuje się wraz z~wykorzystaniem większej liczby drzew losowych. Biorąc pod uwagę czas wykonania, liczba pięciu drzew wydaje się rozsądnym kompromisem pomiędzy całkowitym narzutem czasowym oraz jakością.

    Dla algorytmu przepływu optycznego w~wariancie rzadkim mniejsze wartości minimalnej odległości pomiędzy punktami charakterystycznymi skutkują brakiem narzutu czasowego (wartość ujemna oznacza rezerwę jeśli chodzi o~czas przetwarzania). Biorąc jednak pod uwagę jakość omówioną w~sekcji \ref{Section_Quality} warto zwiększyć ten współczynnik w~celu zwiększenia jakości wyznaczonej ścieżki.

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/overhead/OverheadGL}
      \caption[Narzut czasowy wprowadzony przez każdy algorytm]
              {Narzut czasowy wprowadzony przez każdy algorytm\\(próbka \textit{Person\_G\_L})}
      \label{fig:OverheadGL}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/overhead/RandomForestTrackerOverallOverhead}
      \caption[Całkowity narzut czasowy dla algorytmu wykorzystującego las drzew losowych]
              {Całkowity narzut czasowy dla algorytmu wykorzystującego las drzew losowych}
      \label{fig:RandomForestTrackerOverhead}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=10cm]{charts/overhead/DenseOverheadPerMapSize}
      \caption[Narzut czasowy w~zależności od rozmiaru siatki]
              {Narzut czasowy w~zależności od rozmiaru siatki\\(gęsty przepływ optyczny)}
      \label{fig:SpecialisedDenseOverhead}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=10cm]{charts/overhead/RandomOverheadPerTrainedTreesAmount}
      \caption[Narzut czasowy w~zależności od liczby drzew losowych]
              {Narzut czasowy w~zależności od liczby drzew losowych\\(las drzew losowych)}
      \label{fig:SpecialisedRandomOverhead}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=10cm]{charts/overhead/SparseOverheadPerMinimalDistance}
      \caption[Narzut czasowy w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi]
              {Narzut czasowy w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi (rzadki przepływ optyczny)}
      \label{fig:SpecialisedSparseOverhead}
    \end{figure}

  \section{Wyniki i~wnioski weryfikacji jakości badanych algorytmów}\label{Section_Quality}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/DenseKeypointsPersonG}
      \caption[]
              {}
      \label{fig:DenseKeypointsPersonG}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/DensePathPersonG}
      \caption[]
              {}
      \label{fig:DensePathPersonG}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/DenseKeypointsGestureC}
      \caption[]
              {}
      \label{fig:DenseKeypointsGestureC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/DensePathGestureC}
      \caption[]
              {}
      \label{fig:DensePathGestureC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/RandomKeypointsPersonG}
      \caption[]
              {}
      \label{fig:RandomKeypointsPersonG}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/RandomPathPersonG}
      \caption[]
              {}
      \label{fig:RandomPathPersonG}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/RandomKeypointsGestureC}
      \caption[]
              {}
      \label{fig:RandomKeypointsGestureC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/RandomPathGestureC}
      \caption[]
              {}
      \label{fig:RandomPathGestureC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/SparseKeypointsPersonG}
      \caption[]
              {}
      \label{fig:SparseKeypointsPersonG}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/SparsePathPersonG}
      \caption[]
              {}
      \label{fig:SparsePathPersonG}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/SparseKeypointsGestureC}
      \caption[]
              {}
      \label{fig:SparseKeypointsGestureC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/SparsePathGestureC}
      \caption[]
              {}
      \label{fig:SparsePathGestureC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/KeypointsQualityAC}
      \caption[]
              {}
      \label{fig:KeypointsQualityAC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/KeypointsQualityGO}
      \caption[]
              {}
      \label{fig:KeypointsQualityGO}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/PathQualityAC}
      \caption[]
              {}
      \label{fig:PathQualityAC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/PathQualityGO}
      \caption[]
              {}
      \label{fig:PathQualityGO}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/DenseQualityKeypointsGC}
      \caption[]
              {}
      \label{fig:DenseQualityKeypointsGC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/RandomQualityKeypointsGC}
      \caption[]
              {}
      \label{fig:RandomQualityKeypointsGC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/SparseQualityKeypointsGC}
      \caption[]
              {}
      \label{fig:SparseQualityKeypointsGC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/DenseQualityPathGC}
      \caption[]
              {}
      \label{fig:DenseQualityPathGC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/RandomQualityPathGC}
      \caption[]
              {}
      \label{fig:RandomQualityPathGC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/SparseQualityPathGC}
      \caption[]
              {}
      \label{fig:SparseQualityPathGC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/DenseScatterGC}
      \caption[]
              {}
      \label{fig:DenseScatterGC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/RandomScatterGC}
      \caption[]
              {}
      \label{fig:RandomScatterGC}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=11.5cm]{charts/quality/SparseScatterGC}
      \caption[]
              {}
      \label{fig:SparseScatterGC}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/PathDistanceSparsePerMinimalDistance}
      \caption[Odległość od ścieżki kluczowej w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi]
              {Odległość od ścieżki kluczowej w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi (rzadki przepływ optyczny)}
      \label{fig:SpecialisedSparsePathDistance}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/KeypointsDistanceSparsePerMinimalDistance}
      \caption[Odległość od punktu kluczowego w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi]
              {Odległość od punktu kluczowego w~zależności od minimalnej odległości pomiędzy punktami charakterystycznymi (rzadki przepływ optyczny)}
      \label{fig:SpecialisedSparseKeypointsDistance}
    \end{figure}

    Jak wspomniano w~sekcji \ref{Section_Overhead} i~co widać na wykresach \ref{fig:SpecialisedSparsePathDistance} oraz \ref{fig:SpecialisedSparseKeypointsDistance}, warto zwiększyć wartość współczynnika minimalnej odległości pomiędzy punktami charakterystycznymi, w~celu zmniejszenia maksymalnego błędu (odległości od ścieżek oraz punktów kluczowych). Dzięki temu zmniejszy się również, wartość średnia odległości i~poprawi jakość ścieżki wyznaczonej ze śledzonych punktów.

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/DensePathPerMapSize}
      \caption[]
              {}
      \label{fig:DensePathPerMapSize}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/DenseKeypointsPerMapSize}
      \caption[]
              {}
      \label{fig:DenseKeypointsPerMapSize}
    \end{figure}

    \newpage
    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/RandomPathPerTrainedTreesAmount}
      \caption[]
              {}
      \label{fig:RandomPathPerTrainedTreesAmount}
    \end{figure}

    \begin{figure}[!ht]
      \centering
      \includegraphics[width=14cm]{charts/quality/RandomKeypointsPerTrainedTreesAmount}
      \caption[]
              {}
      \label{fig:RandomKeypointsPerTrainedTreesAmount}
    \end{figure}

  \section{Proponowane usprawnienia}\label{Section_Usprawnienia}

    Na podstawie analizy zawartej w~powyższych podrozdziałach nasuwa się kilka wniosków i~potencjalnych ulepszeń. Zostały one zebrane i~omówione poniżej.

    \begin{itemize}
      \item \textbf{Rozszerzenie sposobu budowania bazy treningowej dla algorytmu wykorzystującego las drzew losowych.}

      Aby zwiększyć jakość klasyfikacji oraz jeszcze bardziej uodpornić algorytm na zmianę kształtu śledzonej dłoni należy udoskonalić proces generacji danych wejściowych. Potencjalnym rozszerzeniem może być wykorzystanie nie tylko pierwszej klatki animacji, do generowania zbioru danych treningowych. Innym rozszerzeniem, może być dodanie kolejnych transformacji źródłowej klatki animacji (np. celowego zniekształcenia perspektywy lub tzw. \textit{rybiego oka} oraz dodatkowego rodzaju szumu).

      \item \textbf{Optymalizacja zużycia pamięci dla algorytmu przepływu optycznego gęstego.}

      W~sekcji \ref{Section_Memory} podczas omawiania zużycia pamięci dla wspomnianego algorytmu dało się zauważyć ciągłą zmianę zużywanej pamięci fizycznej (i~w konsekwencji także wirtualnej, rysunek \ref{fig:OpticalFlowsMemoryUsage}). Ciągła alokacja i~zwalnianie przydzielonych zasobów negatywnie wpływa na czas przetwarzania klatki sekwencji wideo. Narzut ten, może zostać zniwelowany za pomocą zmiany sposobu alokacji pamięci np. poprzez zastosowanie wielokrotnie wykorzystywanej i~współdzielonej puli pamięci.

      \item \textbf{Optymalizacja zużycia pamięci dla algorytmu opartego o drzewa losowe.}

      Omawiany algorytm podczas pracy wykorzystuje bardzo dużo (w~odniesieniu do pozostałych dwóch metod) pamięci fizycznej. W~celu zwiększenia przydatności algorytmu należy przeprowadzić proces optymalizacji zużycia pamięci.

      \item \textbf{Przyspieszenie procesu uczenia, odczytu oraz zapisu bazy treningowej.}

       W~obecnej implementacji przy generacji, zapisie oraz odczycie bazy treningowej wykorzystywany jest jeden wątek (w~konsekwencji również jeden procesor). W~oryginalnym algorytmie (opisanym w~pracy \cite{RandomizedTrees06}) autorzy proponują rozdzielenie omawianych etapów pracy algorytmu na cztery wątki, co zdecydowanie lepiej wykorzystuje możliwości współczesnego sprzętu.
    \end{itemize}

\chapter{Podsumowanie}\label{Section_Podsumowanie}

W~ramach pracy magisterskiej omówiono i~przeprowadzono badania wydajnościowe oraz jakościowe implementacji trzech algorytmów śledzenia punktów charakterystycznych pod kątem wykorzystania ich do analizy ruchu dłoni.

Zebrane rezultaty pozwoliły na jednoznaczne określenie przydatności poszczególnych algorytmów w~badanym obszarze. Dokładne wnioski oraz~decyzje zostały zebrane i~opisane w~poprzednim rozdziale.

Oprócz zaproponowanych implementacji, badań oraz~analizy zostały również zaproponowane usprawnienia i~potencjalne rozszerzenia, które zwiększą jakość oraz poprawia wydajność omawianych metod.